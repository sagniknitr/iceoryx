// Copyright (c) 2019 by Robert Bosch GmbH. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include "iceoryx_posh/internal/mepoo/segment_manager.hpp"
#include "iceoryx_posh/internal/popo/receiver_port.hpp"
#include "iceoryx_posh/internal/popo/sender_port.hpp"
#include "iceoryx_posh/internal/roudi/introspection/process_introspection.hpp"
#include "iceoryx_posh/internal/roudi/port_manager.hpp"
#include "iceoryx_posh/internal/runtime/message_queue_interface.hpp"
#include "iceoryx_posh/mepoo/chunk_header.hpp"
#include "iceoryx_utils/posix_wrapper/posix_access_rights.hpp"

#include <csignal>
#include <cstdint>
#include <ctime>
#include <list>
#include <string>

namespace iox
{
namespace roudi
{
class RouDiProcess
{
  public:
    /// @brief This class represents an application which has registered at RouDi and manages the communication to the
    /// application
    /// @param [in] name of the process; this is equal to the mqueue name, which is used for communication
    /// @param [in] pid is the host system process id
    /// @param [in] payloadMemoryManager is a pointer to the payload memory manager for this process
    /// @param [in] isMonitored indicates if the process should be monitored for being alive
    /// @param [in] payloadSegmentId is an identifier for the shm payload segment
    /// @param [in] sessionId is an ID generated by RouDi to prevent sending outdated mqueue transmission
    RouDiProcess(std::string name,
                 int pid,
                 mepoo::MemoryManager* payloadMemoryManager,
                 bool isMonitored,
                 const uint64_t payloadSegmentId,
                 const uint64_t sessionId);

    RouDiProcess(const RouDiProcess& other) = delete;
    RouDiProcess& operator=(const RouDiProcess& other) = delete;
    /// @note the move cTor and assignment operator are already implicitly deleted because of the atomic
    RouDiProcess(RouDiProcess&& other) = delete;
    RouDiProcess& operator=(RouDiProcess&& other) = delete;
    ~RouDiProcess() = default;

    int getPid() const;

    const std::string& getName() const;

    void sendToMQ(const runtime::MqMessage& f_data);

    /// @brief The session ID which is used to check outdated mqueue transmissions for this process
    /// @return the session ID for this process
    uint64_t getSessionId();

    void setTimestamp(const mepoo::TimePointNs f_timestamp);

    mepoo::TimePointNs getTimestamp();

    mepoo::MemoryManager* getPayloadMemoryManager() const;
    uint64_t getPayloadSegmentId() const;

    bool isMonitored() const;

  private:
    int m_pid;
    runtime::MqInterfaceUser m_mq;
    mepoo::TimePointNs m_timestamp;
    mepoo::MemoryManager* m_payloadMemoryManager{nullptr};
    bool m_isMonitored{true};
    uint64_t m_payloadSegmentId;
    std::atomic<uint64_t> m_sessionId;
};

class ProcessManagerInterface
{
  public:
    /// @brief This is an interface to send messages to processes handled by a ProcessManager
    /// @param [in] name of the process the message shall be delivered
    /// @param [in] message which shall be delivered
    /// @param [in] sessionId the sender expects to be currently valid
    /// @return true if the message was delivered, false otherwise
    virtual bool
    sendMessageToProcess(const std::string& name, const iox::runtime::MqMessage& message, const uint64_t sessionId) = 0;

    // port handling
    virtual ReceiverPortType addInternalReceiverPort(const capro::ServiceDescription& f_service,
                                                     const std::string& f_process_name) = 0;
    virtual SenderPortType addInternalSenderPort(const capro::ServiceDescription& f_service,
                                                 const std::string& f_process_name) = 0;
    virtual void removeInternalPorts(const std::string& f_process_name) = 0;
    virtual void sendServiceRegistryChangeCounterToProcess(const std::string& f_process_name) = 0;
    virtual bool areAllReceiverPortsSubscribed(const std::string& f_process_name) = 0;
    virtual void discoveryUpdate() = 0;

    // enable data-triggering -> based on receiver port
    virtual ~ProcessManagerInterface()
    {
    }
};

class ProcessManager : public ProcessManagerInterface
{
  public:
    /// @todo use a fixed, stack based list once available
    // using ProcessList_t = cxx::list<RouDiProcess, MAX_PROCESS_NUMBER>;
    using ProcessList_t = std::list<RouDiProcess>;
    using PortConfigInfo = iox::runtime::PortConfigInfo;

    ProcessManager(RouDiMemoryInterface& roudiMemoryInterface, PortManager& portManager);
    virtual ~ProcessManager() override
    {
    }

    ProcessManager(const ProcessManager& other) = delete;
    ProcessManager& operator=(const ProcessManager& other) = delete;

    /// @brief Registers a process at the ProcessManager
    /// @param [in] name of the process which wants to register
    /// @param [in] pid is the host system process id
    /// @param [in] user is the posix user id to which the process belongs
    /// @param [in] isMonitored indicates if the process should be monitored for being alive
    /// @param [in] transmissionTimestamp is an ID for the application to check for the expected response
    /// @param [in] sessionId is an ID generated by RouDi to prevent sending outdated mqueue transmission
    bool registerProcess(const std::string& name,
                         int pid,
                         posix::PosixUser user,
                         bool isMonitored,
                         int64_t transmissionTimestamp,
                         const uint64_t sessionId);

    void killAllProcesses();

    void updateLivlinessOfProcess(const std::string& f_name);

    void findServiceForProcess(const std::string& f_name, const capro::ServiceDescription& f_service);

    void
    addInterfaceForProcess(const std::string& f_name, capro::Interfaces f_interface, const std::string& f_runnable);

    void addApplicationForProcess(const std::string& f_name);

    void addRunnableForProcess(const std::string& f_process, const std::string& f_runnable);

    void addReceiverForProcess(const std::string& f_name,
                               const capro::ServiceDescription& f_service,
                               const std::string& f_runnable,
                               const PortConfigInfo& portConfigInfo = PortConfigInfo());

    void addSenderForProcess(const std::string& f_name,
                             const capro::ServiceDescription& f_service,
                             const std::string& f_runnable,
                             const PortConfigInfo& portConfigInfo = PortConfigInfo());

    void initIntrospection(ProcessIntrospectionType* f_processIntrospection);

    void run();

    SenderPortType addIntrospectionSenderPort(const capro::ServiceDescription& f_service,
                                              const std::string& f_process_name);

    /// @brief Notify the application that it sent an unsupported message
    void sendMessageNotSupportedToRuntime(const std::string& f_name);

    // BEGIN ProcessActivationInterface
    /// @brief This is an interface to send messages to processes handled by a ProcessManager
    /// @param [in] name of the process the message shall be delivered
    /// @param [in] message which shall be delivered
    /// @param [in] sessionId the sender expects to be currently valid
    /// @return true if the message was delivered, false otherwise
    bool sendMessageToProcess(const std::string& name,
                              const iox::runtime::MqMessage& message,
                              const uint64_t sessionId) override;
    // END

    // BEGIN PortHandling interface
    ReceiverPortType addInternalReceiverPort(const capro::ServiceDescription& f_service,
                                             const std::string& f_process_name) override;
    SenderPortType addInternalSenderPort(const capro::ServiceDescription& f_service,
                                         const std::string& f_process_name) override;
    void removeInternalPorts(const std::string& f_process_name) override;
    void sendServiceRegistryChangeCounterToProcess(const std::string& f_process_name) override;

    bool areAllReceiverPortsSubscribed(const std::string& f_process_name) override;
    // END

  private:
    RouDiProcess* getProcessFromList(const std::string& f_name);
    void monitorProcesses();
    void discoveryUpdate() override;

    /// @param [in] name of the process; this is equal to the mqueue name, which is used for communication
    /// @param [in] pid is the host system process id
    /// @param [in] payloadMemoryManager is a pointer to the payload memory manager for this process
    /// @param [in] isMonitored indicates if the process should be monitored for being alive
    /// @param [in] transmissionTimestamp is an ID for the application to check for the expected response
    /// @param [in] payloadSegmentId is an identifier for the shm payload segment
    /// @param [in] sessionId is an ID generated by RouDi to prevent sending outdated mqueue transmission
    bool addProcess(const std::string& name,
                    int pid,
                    mepoo::MemoryManager* payloadMemoryManager,
                    bool isMonitored,
                    int64_t transmissionTimestamp,
                    const uint64_t payloadSegmentId,
                    const uint64_t sessionId);

    bool removeProcess(const std::string& f_name);

    RouDiMemoryInterface& m_roudiMemoryInterface;
    PortManager& m_portManager;
    mepoo::SegmentManager<>* m_segmentManager{nullptr};
    mepoo::MemoryManager* m_introspectionMemoryManager{nullptr};
    RelativePointer::id_t m_mgmtSegmentId{RelativePointer::NULL_POINTER_ID};
    mutable std::mutex m_mutex;

    ProcessList_t m_processList;

    ProcessIntrospectionType* m_processIntrospection{nullptr};

    // this is currently used for the internal sender/receiver ports
    mepoo::MemoryManager* m_memoryManagerOfCurrentProcess{nullptr};
};

} // namespace roudi
} // namespace iox

